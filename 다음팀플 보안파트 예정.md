# 다음 프로젝트 보안파트 총정리

## 1. 비밀번호 암호화
- 최신 암호화 알고리즘인 **Argon2** 적용
- 메모리, 반복, 병렬성 등 파라미터 튜닝으로 보안 강화
- 스프링 시큐리티 `Argon2PasswordEncoder` 활용
- 구현 시 과도한 메모리 사용 주의, AWS 환경 고려

## 2. 인증 및 공격 대응
- 무작위 대입 공격(Credential Stuffing) 대비 IP 및 계정별 요청 제한
- 로그인 실패 잠금, CAPTCHA 등 2차 인증 유도 및 선택형 적용
- 주요 10대 웹 공격(SQL Injection, XSS, CSRF 등) 방어 구현
- DoS/DDoS 공격 대응 위해 AWS Shield, WAF, 요청 제한 정책 활용
- 비동기 처리 + 미들웨어(Filter/Interceptor)로 공격 방어 로직 적용

## 3. 인프라 및 서버 안정성
- AWS 로드밸런서 + 오토스케일링으로 트래픽 과부하 대비
- 서버 과부하 시 자동 인스턴스 증설 및 부하 분산
- 리소스 제한 및 요청 큐잉 설계로 정상 유저 보호

## 4. 로그 관리 및 암호화
- 로그 관리자 뷰 구현, DB에 로그 저장
- 로그 데이터에 개인정보 및 보안 이벤트 포함 가능성 고려해 **AES-GCM 등 대칭키 암호화** 적용
- AWS KMS 통한 키 관리 및 키 접근 제어
- 로컬 환경에서는 평문 저장, AWS 배포 시 암호화 로직 전환
- 암호화 키 유출 위험성 대비 및 키 회전 정책 수립

## 5. 2차 인증 및 사용자 인센티브
- 유저가 선택할 수 있는 2차 인증(OTP, 이메일 인증) 도입
- 2차 인증 활성화 유도 위해 포인트/캐시 등 인센티브 제공
- UX 고려한 단계적 보안 강화 및 사용자 참여 유도

## 6. 보안 테스트 도구 활용
- SAST: SpotBugs + FindSecBugs 등 정적 코드 분석 도구 활용
- DAST: OWASP ZAP 등 동적 웹 취약점 스캐너 사용
- CI/CD에 보안 테스트 자동화 포함하여 개발 프로세스에 보안 내재화

## 7. 키 관리 전략
- 운영 환경에서 AWS KMS 같은 전문 키 관리 서비스 활용
- 키 생성, 저장, 접근 통제, 감사, 회전까지 체계적 관리
- 로컬 개발 환경은 환경 변수 또는 별도 키 파일로 관리

## 8. 미래 대비 설계
- 양자컴퓨터 대비 인증 모듈 설계 고민
- 생체 인증, 양자 내성 암호 기술 등 미래 기술 적용 준비
- 인증 모듈 모듈화 및 확장성 확보

---

# 실무자 질문 예상 리스트 & 점검 포인트

## 1. 비밀번호 암호화 (Argon2)
- **파라미터 설정 이유**: 메모리, 반복 횟수, 병렬성 값을 어떻게 결정했나요?  
- **성능 이슈**: 실제 서비스에서 암호화에 따른 서버 부하를 어떻게 관리할 계획인가요?  
- **비밀번호 재설정 정책**: 해시된 비밀번호 변경 시 처리 과정은?  
- **bcrypt와 비교**: Argon2를 선택한 근거와 차별점은 무엇인가요?

## 2. 인증 및 공격 대응
- **브루트포스/크리덴셜 스터핑 대응 구체 방법**: IP 제한, 로그인 실패 잠금 등 상세 구현 방안  
- **2차 인증 선택권 설계**: 사용자 선택형 2차 인증은 어떻게 유도하고 관리할 계획인가요?  
- **보안 취약점 대응 테스트**: SQLi, XSS, CSRF 등은 어떻게 검증했나요?  
- **CAPTCHA 도입 여부 및 방식**: 어떤 상황에서 CAPTCHA를 적용할 것인가요?

## 3. 인프라 및 서버 안정성
- **오토스케일링 조건**: 언제, 어떤 기준으로 인스턴스를 늘리거나 줄이나요?  
- **로드밸런서 구성**: 어떤 로드밸런서를 선택했고, 세부 설정은 어떻게 되나요?  
- **비동기 처리 구현**: 비동기 방식 적용 시 고려해야 할 장애 대응 방법은?  
- **서버 다운 방지 대책**: 갑작스러운 트래픽 폭증에 대한 대응 시나리오는?

## 4. 로그 관리 및 암호화
- **로그 암호화 알고리즘 선택 이유**: AES-GCM 외 대안 검토는?  
- **키 관리 정책**: 키 회전 주기와 정책은 어떻게 수립했나요?  
- **로그 복호화 접근 통제**: 누가 언제 로그를 복호화할 수 있나요?  
- **로그 저장량과 성능**: 암호화로 인한 성능 저하는 어떻게 최소화하나요?

## 5. 2차 인증 및 인센티브
- **인센티브 지급 방식**: 포인트 지급 시 부정 수령 방지 대책은?  
- **2차 인증 미적용 유저 보안 대책**: 인증 안 하는 사용자에 대한 위험 관리는?  
- **인증 수단 선택지**: OTP, 이메일 인증 외 다른 대안은 있나요?  
- **사용자 경험**: 2차 인증 등록 유도 UI/UX 설계는 어떻게 했나요?

## 6. 보안 테스트 도구 활용
- **SAST/DAST 통합 자동화**: CI/CD 파이프라인에 어떻게 연동했나요?  
- **취약점 대응 프로세스**: 발견된 취약점은 어떻게 분류·처리하나요?  
- **테스트 커버리지**: 보안 테스트 범위는 어느 정도인가요?  
- **실제 발견 사례**: 테스트 도중 나온 주요 취약점과 개선 사례는?

## 7. 키 관리 전략
- **AWS KMS 설정 및 정책**: KMS 키 정책, IAM 역할 분리 내용은?  
- **키 노출 시 대응 방안**: 키가 유출된다면 어떻게 대응할 계획인가요?  
- **로컬 환경 키 관리 차이**: 운영 환경과 로컬 환경의 키 관리 차이는?  
- **키 암호화 및 백업**: 키 자체는 어떻게 안전하게 저장하고 백업하나요?

## 8. 미래 대비 설계
- **양자컴퓨터 대응 계획 구체화**: 어떤 양자 내성 알고리즘 검토 중인가요?  
- **생체 인증 도입 시 고려 사항**: 개인정보 보호와 보안 간 균형은 어떻게 맞출 건가요?  
- **모듈화 설계**: 미래 기술 적용을 위해 인증 모듈을 어떻게 설계했나요?  
- **확장성 검증**: 새로운 인증 방식 추가 시 테스트 계획은?

---
---
---
---

---
# 관리자 테이블 분리부터 인증/보안 API 구조까지 정리
> 로그인 로직 순서 바꿈 밑에 정리 다시함!!!! 유저부터 찾고 그 다음 어드민!

## 1. 관리자 테이블을 따로 만드는 이유
- **보안 강화**: 관리자 계정은 권한이 높아 노출 시 피해가 크므로 별도 테이블로 분리해 접근 통제 및 모니터링 강화  
- **권한 및 정책 차별화 용이**: 관리자별로 세분화된 권한, 비밀번호 정책, 2차 인증 적용 가능  
- **감사 및 로그 관리 편의성**: 관리자 로그인과 행위를 별도로 추적해 책임 소재 명확화  
- **확장성·유지보수성 향상**: 관리자별 부서, 역할 등 추가 정보 관리 용이

## 2. 실무에서 관리자 분리 운영 방식
- 초기 소규모 프로젝트는 일반 사용자와 같은 테이블에 role 필드로 구분  
- 규모가 커지고 보안 요구가 높아지면 별도 관리자 테이블로 분리  
- 별도 테이블이면 관리자별 세분화된 권한과 정책 운영 가능  
- 중간 API 레이어나 서비스 계층에서 관리자/사용자 조회 로직 통합 처리

## 3. 로그인 시 관리자/사용자 조회 구조
- 로그인 API 내에서 먼저 관리자 테이블 조회  
- 관리자 계정이 아니면 사용자 테이블 조회  
- 두 테이블을 각각 조회하기 때문에 부하는 약간 증가하지만, DB 캐싱 및 최적화로 충분히 관리 가능  
- 통합 뷰(View)나 캐싱으로 성능 최적화 가능

## 4. 인증 및 권한 관리 API 설계
- **로그인 API**: 사용자 인증, JWT 또는 세션 발급  
- **로그인 유무 확인 API** (`/auth/status`): 현재 로그인 상태와 역할(admin/user) 반환  
- **관리자/사용자 조회 API**: 프로필 조회 등에서 각 사용자 정보 제공  
- **CRUD API (Update/Delete)**: 비밀번호 변경, 계정 탈퇴 등 권한 검증 후 수행  

## 5. API 호출 및 처리 흐름
- 클라이언트는 로그인 성공 시 받은 토큰을 저장  
- 페이지 진입 또는 새로고침 시 로그인 유무 확인 API 호출하여 상태 유지  
- 역할에 따라 UI 및 기능 분기 처리  
- 관리자 전용 API는 토큰 내 역할 검사 후 접근 허용

## 6. 서버 부하 및 최적화
- 두 테이블 조회에 따른 부하는 보통 미미  
- 캐싱, 비동기 처리, DB 뷰 등을 활용해 성능 개선 가능  
- 오토스케일링, 로드밸런서 등 인프라 설계로 트래픽 분산 대응

---

## 결론
- **별도 관리자 테이블 분리는 보안 및 관리 측면에서 유리**  
- 로그인 시 두 테이블 조회, API 통합 레이어 활용으로 클라이언트는 단일 API 호출 가능  
- 로그인 상태 확인, 역할 기반 권한 관리 API 분리로 체계적 인증 시스템 구축  
- 성능은 설계와 인프라로 충분히 보완 가능

---
# 관리자/유저 계정 분리 및 로그인 처리 구조 총정리

## 1. 관리자 테이블 분리 이유
- 보안 강화: 관리자 권한이 높아 별도 테이블로 분리하여 접근 통제 및 모니터링 강화
- 권한 세분화: 관리자별 역할, 비밀번호 정책, 2차 인증 등 맞춤형 보안 정책 적용 가능
- 감사 편의성: 관리자 로그인 및 행위 로그 별도 관리로 책임 소재 명확화
- 유지보수 용이: 관리자 정보 및 권한 확장에 유리

## 2. 실무에서 분리 운영 방식
- 초기에는 통합 테이블(role 필드 사용)로 운영하는 경우 많음
- 보안 요구나 규모에 따라 점차 관리자 테이블 분리
- 분리 시 API 레이어나 서비스 계층에서 관리자/유저 조회 로직 통합 처리

## 3. 로그인 시 관리자·유저 조회 로직
- 로그인 API에서 관리자 테이블 먼저 조회 후, 없으면 유저 테이블 조회
- 두 테이블 조회로 부하 약간 증가하지만 DB 최적화, 캐싱으로 관리 가능
- 뷰(View) 생성이나 캐싱 활용으로 성능 개선 가능

## 4. 인증 및 권한 관리 API 구성
- 로그인 API: 인증 및 토큰(또는 세션) 발급
- 로그인 상태 확인 API: 현재 로그인 여부와 역할(admin/user) 반환
- 유저/관리자 조회 API: 프로필 등 정보 조회
- CRUD API: 비밀번호 변경, 계정 탈퇴 등 권한 검증 후 처리

## 5. 로그인 처리 최적화
- 일반 로그인 요청이 대다수이므로 **유저부터 조회 처리하는 방식 권장**
- 관리자 로그인은 별도 보안 경로 또는 API로 분리하는 게 이상적
- 지연 시간은 미미하여 유저 체감에 큰 영향 없음

## 6. 부하 대응 방안
- 요청 제한(rate limiting), CAPTCHA 등 무작위 대입 공격 방지
- 캐싱, 비동기 처리, 오토스케일링, 로드밸런서 등 인프라 확장
- 관리자 계정에 더 강력한 보안 적용 (Argon2 + 2차 인증 등)


---

## 결론
- **관리자와 유저 계정을 분리하는 것은 실무에서 보안과 운영상 유리한 선택**
- **로그인 로직은 유저 먼저 조회 후 관리자 조회하는 게 서버 부하 절감에 효과적**
- **무작위 대입 공격 등은 로그인 제한 및 인프라 확장으로 대응**

---

# 로그인 처리 부담 감소를 위한 if - else if 구조 정리

## 문제점
- 관리자와 일반 유저를 각각 조회하는 로그인 로직이면
- 모든 로그인 시도마다 두 번의 DB 조회 및 해시 검증 발생
- 서버 CPU, 메모리 사용량 증가로 부하 상승

## 해결책: if - else if 구조 적용
- **일반 유저를 먼저 조회하고 인증 성공 시 관리자 조회를 건너뜀**
- 일반 유저가 대부분이므로 불필요한 관리자 조회 최소화
- 관리자 로그인 시에만 관리자 테이블 조회

## 예시 코드 (스프링 부트)

```java
@PostMapping("/login")
public ResponseEntity<?> login(@RequestBody LoginRequest request) {
    User user = userService.findByUsername(request.getUsername());
    if (user != null && userService.checkPassword(user, request.getPassword())) {
        return ResponseEntity.ok(new LoginResponse("user", user.getId(), ...));
    } else {
        Admin admin = adminService.findByUsername(request.getUsername());
        if (admin != null && adminService.checkPassword(admin, request.getPassword())) {
            return ResponseEntity.ok(new LoginResponse("admin", admin.getId(), ...));
        }
    }
    return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid credentials");
}
```
## 효과 :
- 불필요한 관리자 조회 및 무거운 해시 검증 감소
  - 정상 로그인요청 및 로그인 성공 시 무거운 argon2(어드민 로그인요청) 실행 안해도 됨
  - 물론 비정상적인 요청 혹은 로그인 실패 시 argon2 로직 발동! 이 경우 서버 부담은 비슷해짐
  - 메모리 관리를 위해 정상요청 및 로그인 성공(혹은 회원가입)(비교적 처리해야하는게 많은 유저) 먼저 하기 때매 부담 낮출 수 있음
  - ** 회원가입 시 bcrypt ** 이지만 권한 승격 시 argon2로 바꿔야함
    - 권한 승격 시 기존 비번 삭제 후 랜덤비번 생성 argon2 알고리즘 적용
    - 새 랜덤비번은 이메일로 발송 후 로그인 그리고 알아서 비번 재설정 하게 만들기
      - 유효기간 설정은 추후
    - 관리자 비번은 비번 초기화한지 90일마다 강제로 랜덤비번 바꿔버리고 위 로직 반복
    - 관리자는 인증 필수 user처럼 선택지 없음
- 서버 리소스 사용량 절감
- 로그인 처리 속도 향상
- 사용자 경험 개선

---
## 관리자 테이블 분리 및 인증/보안 API 구조 관련 예상 질문

- 관리자와 일반 사용자 테이블을 분리한 근거와 기대 효과는 무엇인가요?  
- 관리자 계정 별도 테이블 운영 시 보안상 어떤 이점이 있나요?  
- 로그인 시 관리자/사용자 테이블을 각각 조회하는 구조의 성능 이슈는 어떻게 해결하나요?  
- 관리자와 사용자 로그인 API를 통합하는 방안은 무엇인가요?  
- 관리자 권한 및 인증 정책은 일반 사용자와 어떻게 다르게 설계했나요?  
- API 호출 시 역할에 따른 권한 검증은 어떻게 구현되나요?  
- 관리자와 사용자 간 권한 상승이나 역할 변경은 어떻게 처리하나요?  
- 분리된 관리자 테이블과 일반 사용자 테이블 간 데이터 동기화나 관리 이슈는 없나요?  
- 대규모 서비스에서 이 구조가 확장성에 미치는 영향은 무엇인가요?  
- 개발·운영 측면에서 관리자 테이블 분리가 미치는 영향과 장단점은 무엇인가요?  


---
---
---
---
# JWT vs 세션 로그인 비교 및 다음 프로젝트 적용 방안

---

## 1. JWT (JSON Web Token) 로그인

### 장점
- 무상태(stateless) 인증으로 서버 확장성 우수
- 클라이언트(브라우저, 모바일)에서 토큰 저장 및 전송으로 REST API와 잘 맞음
- 액세스 토큰 + 리프레시 토큰 구조로 보안 강화 가능
- 서버에 별도 세션 저장소 필요 없음

### 단점
- 토큰 탈취 시 유효기간 내 공격 가능 (리프레시 토큰 관리 필요)
- 토큰 취소(로그아웃 등) 처리 어려움 (Blacklist 등 추가 구현 필요)
- 토큰 크기가 커서 네트워크 부하 증가 가능

---

## 2. 세션 로그인

### 장점
- 서버가 직접 세션 관리 → 즉각적인 세션 무효화 가능 (로그아웃 시 즉시 적용)
- 세션 아이디만 주고받아 토큰보다 크기 작음
- 전통적인 웹 서비스에 익숙하고 안정적

### 단점
- 서버에 세션 상태 저장 → 확장성에 한계 (세션 클러스터링 필요)
- REST API나 모바일 환경과 맞지 않을 수 있음
- 서버 메모리 사용 증가 가능

---

## 3. 다음 프로젝트 로그인 방식 적용 방안

| 사용자 유형 | 로그인 방식 | 이유 및 설명 |
| ----------- | ------------ | ------------ |
| 일반 유저  | JWT 인증 (액세스 토큰 + 리프레시 토큰) | SPA 및 모바일 지원에 유리하고 확장성 뛰어남. 대부분 유저가 이 방식으로 빠르게 인증 및 API 호출 수행. |
| 관리자    | 세션 인증 + Argon2 해시 | 보안이 특히 중요한 관리자 계정은 서버에서 직접 세션 관리해 권한 통제 강화. Argon2로 비밀번호 강력 암호화 적용. |

### 참고
- 로그인 API는 유저 먼저 조회 → 인증 성공 시 관리자 인증 로직 건너뜀(서버 부하 감소)
- JWT는 토큰 관리(발급, 갱신, 폐기) 로직과 보안 강화 필수
- 세션은 세션 스토리지(메모리, Redis 등) 관리 필요

---

## 결론

- **일반 유저에게는 JWT 인증으로 현대 웹 환경에 최적화**
- **관리자는 세션 로그인으로 강력한 보안과 즉시 세션 제어 가능**
- 각 방식의 장단점을 살려 역할에 맞게 적용함으로써 보안과 성능의 균형 추구







